---
title: "An outbreak of gastroenteritis in Stegen, Germany, June 1998"
author: "Janetta Skarp, Zhian N. Kamvar, Alexander Spina, Patrick Keating and Thibaut Jombart"
authors: ["Thibaut Jombart", "Janetta Skarp", "Zhian N. Kamvar", "Alexander Spina", "Patrick Keating"]
categories: "case studies"
tags: ["level: beginner", "epicurve", "single variable analysis", "2x2 tables", "gastroenteritis", "plotting ases"]
date: 2018-10-24
slug: stegen
licenses: CC-BY
image: img/highres/graduation-1965.jpg
showonlyimage: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, warning = FALSE)
```

# Context

On 26 June 1998, the St Sebastian High School in Stegen (school A), Germany,
celebrated a graduation party, where 250 to 350 participants were
expected. Attendants included graduates from that school, their families and
friends, teachers, 12th grade students, and some graduates from a nearby school
(school B).


A self-service party buffet was supplied by a commercial caterer from a the nearby city of
Freiburg. Food was prepared on the day of the party and transported in a
refrigerated van to the school. Relative locations of the two schools and Freiburg can be seen on image 1

![Image 1: Map of Stegen, with annoted school A and B](../../img/screenshots/map_stegen.png)


<!--
Please find the HTML for the iframe of the embedded interactive map: <iframe src="https://www.google.com/maps/d/u/0/embed?mid=1xYZh1AyB3h_mG4QihrO9LhFT3g5tjOv_" width="640" height="480"></iframe>
--> 

Festivities started with a dinner buffet open from 8.30 pm onwards and were
followed by a dessert buffet offered from 10 pm. The party and the buffet
extended late into the night and alcoholic beverages were quite popular. All
agreed it was a party to be remembered.

## The alert

On 2nd July 1998, the Freiburg local health office reported to the Robert Koch
Institute (RKI) in Berlin a significant increase of cases of gastroenteritis in the munipality of Stegen
following the graduation party described above. More than 100 cases were
suspected among participants and some of them were so ill that they were admitted to nearby
hospitals. Sick people showed symptoms like; *fever, nausea, diarrhoea and vomiting*
lasting for several days. Stool samples were collected from several ill cases and send to the laboratory in Freiburg for microbiological identification. *Salmonella enteritidis* was identified in 19 stool samples.

In response to the large number of cases associated with the dinner the Freiburg health office sent an outbreak control team to investigate the kitchen of the caterer in Freiburg. Food preparation procedures were reviewed. Samples were taken of remaining food items after the graduation ceremony and were sent to the laboratory of Freiburg University. Microbiological analyses were performed on samples of the following food items:
brown chocolate mousse, caramel cream, remoulade sauce, yoghurt dill sauce, and
10 raw eggs. Unfortunately no tiramisu was left over after the dinner so no samples were tested of this specific food item. 

The Freiburg health office requested help from the RKI in the investigation to
assess the magnitude of the outbreak and identify potential vehicle(s) and risk
factors for transmission in order to better control the outbreak.



## The epidemiological study

**Case definition**: cases were defined as any person who had attended the party
at St Sebastian High School and who suffered from *diarrhoea* (min. 3 loose
stool for 24 hours) between 27 June and 29 June 1998, or from at least three of
the following symptoms: *vomiting*, *fever over 38.5Â° C*, *nausea*, 
*abdominal pain*, *headache*.

Students from both schools attending the party were asked through phone
interviews to provide names of persons who attended the party.

Overall, 291 responded to enquiries and 103 cases were identified. The linelist
analysed in this case study was built from these 291 responses.


## This case study

In this case study, we will take you through the analysis of this epidemic using R. This
will be the occasion to illustrate more generally useful practices for data
analysis using **R**, including:

- how to read and import data from Excel
- how to explore data using tables and summaries
- how to clean data
- how to make graphics to describe the data
- how to test if specific food items are linked to the disease
- how to plot a very basic spatial overview of cases





# Initial data processing

## Loading required packages

The following packages will be used in the case study:

- *here*: to find the path to data or script files
- *readxl*: to read Excel spreadsheets into **R**
- *incidence*: to build epicurves
- *epitrix*: to clean labels from our spreadsheet
- dplyr: to help with factors
- ggplot2: to create custom visualisations

If we have these packages installed, we can tell R to load these packages from
our R library:

```{r stegen_libraries, warning=FALSE, message=FALSE}
library("here")      # find data/script files
library("readxl")    # read xlsx files
library("incidence") # make epicurves
library("epitrix")   # clean labels and variables
library("dplyr")     # general data handling
library("ggplot2")   # advanced graphics
```

<details>
<summary> <b> Package not installed? Did you get an error? </b> </summary>

Note that you will get an error if the packages have not been installed on your
system. To install them (you only need to do this once!), type:

```{r stegen_install_libraries, eval = FALSE}
install.packages("here")
install.packages("readxl")
install.packages("incidence")
install.packages("epitrix")
install.packages("dplyr")
install.packages("ggplot2")
```

</details>

Loading these packages makes all functions implemented by the packages
available, so that `function_name()` can be used directly (without the
`package_name::` prefix). This is not a problem here as these packages do not
implement functions with identical names.



## Importing data from Excel

Linelist data can be read from various formats, including flat text files (e.g.
`.txt`, `.csv`), other statistical software (e.g. STATA) or Excel spreadsheets.
We illustrate the latter, which is probably the most common format.  We assume
that [the data file `stegen_raw.xlsx`](../../data/stegen_raw.xlsx) has been
saved in a `data/` folder of your project, and that your current R session is
at the root of the project.


Here we decompose the steps to read data in: finding the path to the data
(`path_to_data`), using the function `read_xlsx()` from the *readxl* package to
read data in, and saving the output in a new object `stegen`:

```{r eval = FALSE}
path_to_data <- here("data", "stegen_raw.xlsx")
stegen <- read_xlsx(path_to_data)
```

```{r stegen_read_data, results = 'hide', echo = FALSE}
stegen <- readxl::read_xlsx(here::here("static", "data", "stegen_raw.xlsx"))
```

To print the content of the dataset, we can use either of these commands:

```{r stegen_print_data, eval = 1}
stegen
View(stegen)
```


<details>

<summary><b>Problems?</b> In case of trouble, click here to toggle additional help:</summary>


If the above fails, you should check:

- that your data file has been saved in the right folder, with the right name
  (lower case and upper case do matter)
- that your R session was started from the right project - if unsure, close R
and re-open Rstudio by double-clicking on the `.Rproj` file 
- that all packages are installed and loaded (see installation guidelines above)

</details>


## Overview and summaries

We first have a quick look at the content of the data set. The information we are looking for is:

- the numbers of cases (rows) and variables (columns) in the data
- the *name* of the variables: do they use consistent capitalisation and separators?
- the *type* of the variables: are dates, numeric or categorical variables used when they should?
- the *coding* of the variables: are explicit labels (e.g. `"male"`/`"female"`) used where relevant?

We first check the dimensions of the `stegen` object, and the name of the variables:

```{r stegen_dim}
dim(stegen) # rows x columns
names(stegen) # column labels
```

We can now try and summarise the dataset using:

```{r stegen_summary}
summary(stegen)
```

Note that binary variables, when treated as numeric values (0/1), are summarised
as such, which may not always be useful. As an alternative, `table()` can be used
to list all possible values of a variable, and count how many time each value
appears in the data. For instance, we can compare the `summary()` and `table()` for
consumption of `tiramisu`:

```{r stegen_summary_table}
stegen$tiramisu # all values
summary(stegen$tiramisu) # summary
table(stegen$tiramisu) # table
```


**Good news**: the dataset has the expected dimensions, and all the relevant
variables seem to be present. There are, however, **a few often observed issues**: 

1. variable names are a bit messy, and include different separators, spaces, and
  irregular capitalisation
2. variable types are partly wrong: 
    - *unique keys* should be `character` (i.e. character strings)
    - *dates of onset* should be `Date` (**R** is good at handling actual dates)
    - *illness* and *sex* should be `factor` (i.e. a categorical variables)
3. labels used in some variables are ambiguous:
    - *sex* should be coded explicitely, not as 0 (here, male) and 1 (here,
      female)
	- *illness* should be coded explicitely, not as 0 (here, non-case) and 1 (case)
4. some binary variables have maximum values of 9 (see `summary(stegen)`)


## Data cleaning

While it is tempting to go back to the Excel spreadsheet to fix issues with
data, it is almost always quicker and more reliable to clean data in **R**
directly. Here, we make a copy of the old data set, and clean `stegen` before
further analysis.

```{r stegen_old}
stegen_old <- stegen # save 'dirty data'
```

We use *epitrix*'s function `clean_labels()` to standardise the variable names:

```{r stegen_clean_labels}
new_labels <- clean_labels(names(stegen)) # generate standardised labels
new_labels # check the result
names(stegen) <- new_labels
```

We set convert the unique identifiers to character strings (`character`), dates
of onset to actual `Date` objects, and sex and illness are set to categorical variables (`factor`):

```{r stegen_unique_ids}
stegen$unique_key <- as.character(stegen$unique_key)
stegen$sex <- factor(stegen$sex)
stegen$ill <- factor(stegen$ill)
stegen$date_onset <- as.Date(stegen$date_onset)
```

We use the function `recode()` from the *dplyr* package to recode `sex` more
explicitely:

```{r stegen_recode}
stegen$sex <- recode_factor(stegen$sex, "0" = "male", "1" = "female")
stegen$ill <- recode_factor(stegen$ill, "0" = "non case", "1" = "case")
```


Finally we look in more depth into these variables having maximum values of 9,
where we expect 0/1; `table()` is useful to list all values taken by a variable,
and listing their frequencies:

```{r stegen_nines}

table(stegen$pork)
table(stegen$salmon)
table(stegen$horseradish)

```

The only rogue values are `9`; they are likely either data entry issues, or
missing data, which in **R** should be coded as `NA` ("not available"). We can
replace these values using:

```{r stegen_replace_9}
stegen$pork[stegen$pork == 9] <- NA
stegen$salmon[stegen$salmon == 9] <- NA
stegen$horseradish[stegen$horseradish == 9] <- NA
```


<details>

<summary> <b> Going further </b> Why does this work? Click here for more details. </summary>


There are several things going on in a command like:

```{r eval = FALSE}
stegen$pork[stegen$pork == 9] <- NA
```

let us break them down:

1. `stegen$pork` means "get the variable called `pork` in the dataset `stegen`"
2. `[...]` subset the vector according to `...`; if `...` is a series of
   `TRUE/FALSE` values, only entries corresponding to `TRUE` are retained
3. `... == 9` for each value of `...`  test if it is equal to `9`, and return `TRUE` if so (`FALSE` otherwise) 
4. `... <- NA` replace `...` with `NA` (missing value)

in other words: "isolate the entries of `stegen$pork` which equal `9`, and
replace them with `NA`; here is another toy example to illustrate the procedure:

```{r stegen_subset}
## make toy input vector
toy_vector <- 1:5
toy_vector

## make toy logical vector for subsetting
toy_logical <- c(FALSE, TRUE, TRUE, FALSE, TRUE)
toy_logical
toy_vector[toy_logical] # subset values
toy_vector[toy_logical] <- 0 # replace subset values
toy_vector # check outcome

```

</details>

## Saving clean data

Now that we've cleaned our data, we will probably want to re-use it in further
analyses, but we probably don't want to go through the steps of cleaning it
again. Here, we will save our cleaned data into a new folder under `data/`
called `cleaned/`. We will use **R**'s function `dir.create()` to create this
folder under our data folder:

```{r create-clean-dir, eval = FALSE}
clean_dir <- here("data", "cleaned")
dir.create(clean_dir)
```

After this, we can save our cleaned data into a new file called 
`stegen_clean.csv`:

```{r save-clean-data, eval = FALSE}
stegen_clean_file <- here("data", "cleaned", "stegen_clean.csv")
write.csv(stegen, file = stegen_clean_file, rownames = FALSE, sep = ",")
```


# Data exploration


## Summaries of age and sex distribution

It is good practice to first start to explore and familiarise yourself with a dataset before heading into the analyses of your data. We can have a brief look at age and sex distributions using some basic
summaries; for instance:

```{r stegen_age_sex}
summary(stegen$age) # age stats
summary(stegen$sex) # gender distribution
tapply(stegen$age, INDEX = stegen$sex, FUN = summary) # age stats by gender      
```



<details>
<summary> <b>Going further</b> click here to learn about <code>tapply()</code>: </summary>

`tapply()` is a very handy function to stratify any kind of analyses. You will
find more details by reading the documentation of the function `?tapply()`, but
briefly, the syntax to be used is `tapply(input_data, stratification,
function_to_use, optional_arguments)`. In the command used above:

```{r eval = FALSE}
tapply(stegen$age, INDEX = stegen$sex, FUN = summary)
```

this literally means: select the age variable in the dataset `stegen`
(`stegen$age`), stratify it by sex (`stegen$sex`), and summaries each strata
(`summary()`). So for instance, to get the average age by sex (function `mean()`), one could use:

```{r stegen_age_per_sex}
tapply(stegen$age, INDEX = stegen$sex, FUN = mean, na.rm = TRUE)
```
Here we illustrate that further arguments to the function can be passed as extra
arguments; here, `na.rm = TRUE` means "ignore missing data".

</details>



## Graphical exploration

The summaries above may be useful for reporting purposes, but graphics are
usually better for getting a feel for the data. Here, we illustrate how the
package *ggplot2* can be used to derive informative graphics of age/sex
distribution. It implements an alternative graphics system to the basic **R**
plots, in which the plot is built by adding (literally using `+`) different
layers of information, using:

- `ggplot()` to specify the dataset to use
- `geom_...()` functions which define a type of graphics to use (e.g. barplot, histogram)
- `aes()` to map elements of the data into aesthetic properties (e.g. x/y axes, color, shape)

For instance, to get an histogram of age:

```{r stegen_histogram}
ggplot(stegen) + geom_histogram(aes(x = age))
```

Color can be added using:

```{r stegen_histogram_sex}
ggplot(stegen) + geom_histogram(aes(x = age, fill = sex))
```

Here, the age distribution is pretty much identical between male and female.

<details>
<summary> <b> Going further:</b> click here to learn about customising <i>ggplot2</i> graphics:</summary>

*ggplot2* graphics are highly customisable, and a lot of help and examples can
be found online. The [official website](https://ggplot2.tidyverse.org/) is a good place to start.

For instance, here we:

- define the width of each bin to be 1 year (`binwidth = 1` to avoid the warning from above)
- add white borders to the plot (`color = "white"`)
- specify colors manually for male / female, using specified color codes (see
  [html color picker](https://www.w3schools.com/colors/colors_picker.asp) to
  define your own colors) (`scale_fill_manual(...)`)
- add labels for title, *x* and *y* axes (`labs()`)
- specify a lighter general color theme, using Times font of a larger size by default (`theme_light(...)`)
- move the legend inside the plot (`theme(...)`)

Note, it's best practice to include only one *ggplot2* command per line if you
are using more than two.

```{r stegen_ggplot2_custom}
ggplot(stegen) + 
  geom_histogram(aes(x = age, fill = sex), binwidth = 1, color = "white") +
  scale_fill_manual(values = c(male = "#4775d1", female = "#cc6699")) +
  labs(title = "Age distribution by gender", x = "Age (years)", y = "Number of cases") +
  theme_light(base_family = "Times", base_size = 16) +
  theme(legend.position = c(0.8, 0.8))
```

</details>


## Epidemic curve

Incidence curves can be built using the package *incidence*, which will compute
the number of new cases given a vector of dates (here, onset) and a time
interval (1 day by default). We use the function `incidence()` to achieve this, and
then visualise the results:

```{r stegen_incidence}
i <- incidence(stegen$date_onset)
i
plot(i)
```

Details of the case counts can be obtained using:

```{r stegen_case_counts}
as.data.frame(i)
```

How long is this outbreak? It looks like most cases occurred over the course of
3 days, but that cases kept showing up 10 days after the peak. Is this true? Not
really. Stratifying the epidemic curve by case definition will clarify the
situation:

```{r incidence_stratified}
i_ill <- incidence(stegen$date_onset, group = stegen$ill)
i_ill
as.data.frame(i_ill)
plot(i_ill, color = c("non case" = "#66cc99", "case" = "#990033"))
```

The outbreak really only happened over 3 days: onsets reported after did not
match the epi case definition. This is compatible with a food-borne outbreak
with limited or no person-to-person transmission.


Note that the plots produced by *incidence* are *ggplot2* objects, so that the
options seen before can be used for further customisation (see below).


<details>
<summary> <b> Going further</b> click here to learn about the <i>incidence</i> package: </summary>


More information on the *incidence* package can be found from the
[dedicated website](https://www.repidemicsconsortium.org/incidence/). Here, we illustrate how incidence can be stratified e.g. by case definition:

We can also customise this graphic like other *ggplot2* plots (see [this tutorial](https://www.repidemicsconsortium.org/incidence/articles/customize_plot.html) for more):

```{r incidence_stratified_custom}
plot(i_ill, border = "white", color = c("non case" = "#66cc99", "case" = "#990033")) + 
  geom_hline(yintercept = 1:55, color = "white") +
  labs(title = "Epicurve by case", x = "Date of onset", y = "Number of cases") +
  theme_light(base_family = "Times", base_size = 16) +
  theme(legend.position = c(0.8, 0.8)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```

</details>



## Age and gender distribution of the cases

We use the same principles as before to visualise the distribution of illness by
age and gender. To split the plot into different panels according to `sex`, we
use `facet_grid()` (see previous extra info on *ggplot2* customisation for
further details otions):

```{r stegen_case_age_sex}
ggplot(stegen) + 
  geom_histogram(aes(x = age, fill = ill)) +
  scale_fill_manual("Illness", values = c("non case" = "#66cc99", "case" = "#990033")) +
  facet_grid(sex ~ .) + 
  labs(title = "Cases by age and gender") + 
  theme_light()
```

Illness does not seem to be depending on age or gender. This can be tested: this
is the topic of the next and final section.



# Looking for the culprits

## Univariate tests

Methods for testing the association between two variables can be broken down in 3 types,
depending on which types these variables are:

1. **2 quantitative variables**: Pearson's correlation coefficient ($r$) and similar
  methods
2. **1 quantitative, 1 categorical**: ANOVA types of approaches; particular case with
  2 groups: Student's $t$-test
3. **2 categorical variables**: Chi-squared test on the 2x2 table
  (a.k.a. *contingency* table) and similar methods (e.g. Fisher's exact test)


We can use these approaches to test if the disease is linked to any of the other
recorded variables. As illness itself is a categorical variable, only approaches
of type 2 and 3 will be illustrated here.


### Is illness linked to age?

We can use the function `t.test()` to test if the average age is different across
illness status. As this test assumes that the two categories exhibit similar
variation, we first ensure that the variances are comparable using Bartlett's
test. The syntax `variable ~ group` is used to indicate the variable of interest (left hand-side), and the group
 (right hand-side):

```{r stegen_bartlett_test}
bartlett.test(stegen$age ~ stegen$ill)
```

The resulting p-value (`r round(bartlett.test(stegen$age ~ stegen$ill)[["p.value"]], 3)`) suggests the variances are indeed comparable. Wecan thus proceed to a $t$-test:


```{r stegen_t_test}
t.test(stegen$age ~ stegen$ill, var.equal = TRUE)
```

The p-value of `r round(t.test(stegen$age ~ stegen$ill, var.equal = TRUE)[["p.value"]], 3)` confirms the previous graphics: the illness does not seem to be linked to age.



### Is illness linked to gender?

To test the association between gender and illness (2 categorical variables), we
first build a 2-by-2 (contingency) table, using:

```{r stegen_2by2}
tab_ill_sex <- table(stegen$ill, stegen$sex)
tab_ill_sex
```

Note that proportions can be obtained using `prop.table`:

```{r stegen_prop_table}
## basic proportions
prop.table(tab_ill_sex)

## expressed in %, rounded:
round(100 * prop.table(tab_ill_sex))
```

Once a contingency table has been built, the Chi-square test can be run using `chisq.test`:

```{r stegen_chisq}
chisq.test(tab_ill_sex)
```

Here, the p-value of `r round(chisq.test(tab_ill_sex)[["p.value"]], 3)` suggests illness is not related to sex either.


## Making multiple tests

The natural next step is to run multiple tests for all potential risk factors
recorded. There are many ways to go about this in **R**, but we will illustrate
one of the most common workflows:

1. isolate a subset of variables to test (the ones indicative of food consumption) (using `[]`)
2. for each:
    i) build contingency table with illness status (using `table`)
    ii) run a Chi-square test on this table (using `chisq.test`)

All of these have been seen so far; the only missing piece is step 2), which we
will cover using a very handy function called `lapply()`.


### Isolating the variables to test

We use the natural structure of the dataset, as variables representing food
consumption are all the last columns:

```{r stegen_isolate_food}
names(stegen)
```

In this case, we need to retain columns 6 to 21, excluding `tportion` and
`mportion`, which are not binary; this can be done using the subsetting operator
`[...]`, where `...` are numbers indicating the columns to retain:

```{r stegen_food}
to_keep <- c(6, 8, 9, 10, 12:21)
to_keep
food <- stegen[to_keep]
food
```


### Building several contingency tables

There are many variables to test, and having to enter separate command lines for
each would be cumbersome and prone to errors. As a workaround, the function
`lapply()` can be used. This function allows to repeat an operation using a vector
of inputs, using each element in turn. Its general syntax is
`lapply(vector_of_inputs, function_to_use, other_arguments)`, where
`other_arguments` can be any secondary arguments taken by
`function_to_use()`. Here, we use it to build a separate contingency table of each
variable in `food` crossed with illness status (`stegen$ill`); note that we show
only the first few tables:

```{r stegen_food_tables, echo = c(1,3), eval = -2}
food_tables <- lapply(food, table, stegen$ill)
food_tables
head(food_tables)
```


### Realising multiple Chi-squared tests

The same principle used to compute several contingency tables can be used to
compute Chi-square tests for each table, using `lapply()`; note that we show
only the first few tests:

```{r stegen_food_tests, echo = c(1,3), eval = -2}
food_tests <- lapply(food_tables, chisq.test)
food_tests
head(food_tests)
```

Looking at these results, it seems a large number of food items are
significantly correlated to the illness. Which food item is the biggest suspect?
We will try and address this question using risk ratios.



## Risk ratios

### For one variable 

The [risk ratio](https://en.wikipedia.org/wiki/Risk_ratio) is defined as the
ratio between the proportion of illness in one group (typically 'exposed') vs
another ('non-exposed'). For instance, let us consider the contingency table of
pork consumption and illness:

```{r stegen_pork_table}
food_tables$pork
```

This can be turned into proportions using `prop.table()`, specifying that we want
proportions by rows (`margin = 1`):

```{r stegen_pork_prop}
pork_prop <- prop.table(food_tables$pork, margin = 1)
pork_prop
```

the corresponding risk ratio is:

```{r stegen_pork_rr}
## ill & exposed: row 2, column 2
pork_prop[2, 2] # row 2, column 2

## ill & non-exposed: row 1, column 2
pork_prop[1, 2]

## compute the risk ratio
pork_rr <- pork_prop[2, 2] / pork_prop[1, 2]
pork_rr
```

Note the use of the syntax `[rows, columns]` to subset specific rows and columns
of 2-dimensional objects.


### Multiple variables

In the example above, we have computed the risk ratio using a simple recipe:

1. select a contingency table
2. convert raw numbers to proportions (using `prop.table()`)
3. isolating the risks in exposed and non-exposed groups, and compute their
   ratio

Repeating these tasks manually for all variables in `food` would be
cumbersome. As an alternative, we can define the steps above as a function,
i.e. a generic recipe which we can then apply to any contingency table. This new
function will be called `risk_ratio()`, and is defined as follows:

```{r stegen_risk_ratio_function}
risk_ratio <- function(tab) { # 'tab' is a placeholder for the input 2x2 table
  ## compute table of proportions
  tab_prop <- prop.table(tab, margin = 1)
  
  ## compute the risk ratio
  result <- tab_prop[2, 2] / tab_prop[1, 2]

  ## return the output
  return(result) # this will be the output of the function
}
```

We can now try this function on any of the tables in `food_tables`, for instance:

```{r rr_demo}
food_tables$pork
risk_ratio(food_tables$pork)
```

And we can now apply this function sequentially to all variables in `food` as
before, using `lapply()` (we show only the first few values):

```{r stegen_all_rr, echo = 1:2, eval = -2}
all_rr <- lapply(food_tables, risk_ratio)
all_rr
head(all_rr)
```

Finally, we re-shape these results into a sorted data frame for further plotting
with *ggplot2*. Reshaping will take three steps:

1. convert from a list to a vector using `unlist()`
2. sort the vector using `sort()`
3. convert the named vector to a data frame using `stack()` (from the *utils* package)

<details>
<summary><b>Going Further</b> click here to learn more about <code>stack()</code></summary>

The first two functions, `unlist()` and `sort()` have self-explanitory names, 
but `stack()` may not be so clear. This function takes the elements in a vector
and **stacks** them together to make a data frame with two columns: one column 
called "values" containing the data in the vector, and the other column called 
"ind" containing the names of those elements as a factor.

</details>

```{r stegen_rr_plot}
## convert results from list to numeric vector
rr_data <- unlist(all_rr)
rr_data

## sort results by decreasing order
rr_data <- sort(rr_data, decreasing = TRUE)

## create a data frame from the named vector
rr_df   <- stack(rr_data)
rr_df

ggplot(rr_df, aes(x = values, y = ind)) +
  geom_point() +
  geom_vline(xintercept = 1, lty = 2) +
  geom_segment(aes(xend = 1, yend = ind)) +
  theme_light(base_size = 16, base_family = "Times") +
  labs(title = "Risk Ratio by Food Exposure", x = "Risk Ratio", y = "Food Item")
```

The results are a lot clearer now: the tiramisu is by far the largest risk
factor in this outbreak.

# Plotting a very basic spatial overview of cases
To complete your report, you would like to include a very basic spatial overview of cases. Based on the postal codes of all individuals with a date of symptom onset spatial coordinates were generated providing everyone with a latitude and longitude which corresponds with their household (in relation to their postal code). The variables *lat* and *long* include the longitude and latitude which we will use to plot the cases using *ggplot2*.

<details>
<summary>Advanced mapping and spatial methodologies?</b> </summary>

Normally you would generate maps in R using more sufisticated mapping tools, but for the scope of this case study we will keep it more basic. We will explore mapping and spatial analytical methods this in future case studies

</details>

# Conclusion

This case study illustrated how **R** can be used to import data, clean data,
and derive basic summaries for a first glance at the data. It also showed how to
generate graphics using *ggplot2*, and how to detect associations between
several potential risk factors and the occurrence of illness. One major caveat
here is that we are not accounting for potential confounding factors. These will
be treated in a separate case study, which will focus on the use of logistic
regression in epidemic studies. Lastly we plotted a basic overview of the cases in this outbreak in relative distance to each other. More suffisticated mapping and spatial mathodologies will be covered in other case studies. 



<br>
<br>
<br>




# About this document

## Source

This case study was first designed by Alain Moren and Gilles Desve, EPIET. It is
based on an real outbreak investigation conducted by Anja Hauri, RKI, Berlin, 1998.

## Contributors

- original version: Alain Moren, Gilles Desve

- reviewers, previous versions: Marta Valenciano, Alain Moren

- adaptation for EPIET module: Alicia Barrasa, Ioannis Karagiannis

- rewriting for R: Alexander Spina, Patrick Keating, Janetta Skarp, Zhian N. Kamvar, Thibaut Jombart


Contributions are welcome via [pull
requests](https://github.com/reconhub/learn/pulls). The [source file for this case study can be found
here](https://github.com/reconhub/learn/blob/master/content/post/practical-stegen.Rmd).



## Legal stuff

**License**: [CC-BY](https://creativecommons.org/licenses/by/3.0/)
**Copyright**: 2018 

<br>
<br>
